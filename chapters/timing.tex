\chapter{Timing attacks}
\index{Timing attacks}Come anticipato nel capitolo precedente, approfondiremo adesso la tipologia di attacchi basati sul tempo. 

I timing attacks si basano sulla misurazione del tempo necessario ad un dispositivo per effettuare un'operazione. Tale informazione può portare all'esposizione di alcune informazioni sull'operazione stessa o sui dati da essa manipolati. Questo accade perché molto spesso la durata di un'operazione dipende dagli input che vengono forniti. Le istruzioni che prestano maggiormente il fianco a questo tipo di attacchi sono le istruzioni di branch e i condizionali.

\begin{center}
	\lstinputlisting[language={Java}, caption={esempio di funzione vulnerabile ad un timing attack}, label={list:timingBase}, frame={none},basicstyle={\small\ttfamily}]{code/timingBase.txt}
\end{center}

Ad esempio il \cref{list:timingBase} se fatto girare con la stringa "\texttt{passwordToBeStolen}" impiegherà un tempo maggiore rispetto allo stesso programma fatto girare con la stringa "\texttt{foo}". Nel primo caso infatti verrà scansionata tutta la stringa mentre nel secondo caso si interromperà immediatamente. Questa informazione può essere utilizzata dall'attaccante che, procedendo per tentativi, può arrivare a ricavare la stringa esatta.

Questo esempio banale non deve portare a pensare che le caratteristiche temporali di una certa operazione rivelino solamente informazioni su una piccola parte di un intero sistema crittografico. Come dimostrato da \emph{Kocher} in \cite{kocher1996timing}, esistono attacchi che, solamente sfruttando misurazioni di tempi di esecuzione di particolari operazioni, riescono a scoprire l'intera chiave in algoritmi crittografici complessi come \emph{RSA}, \ac{DH} o \ac{DSS}.

Per ottenere tali risultati le misurazioni dei tempi vengono analizzate con un modello statistico che fornisce, con un certo intervallo di confidenza, la chiave progredendo di un bit alla volta. Il modello deve essere in grado di controllare la correlazione tra le varie misurazioni e stabilire di conseguenza se il successivo bit della chiave debba essere $0$ oppure $1$.

	\section{Attacchi reali}
	
	Analizziamo tre attacchi reali presi proprio dall'articolo di \emph{Kocher}.
	
		\subsection{Esponenziazione modulare}
		Un operazione comune, utilizzata sia da \ac{DH} che da RSA, è il calcolo di $$R = y^{x} \ mod \ n.$$ In questa operazione, $n$ è pubblico e $y$ può essere trovato tramite una qualche intercettazione di messaggi da parte dell'attaccante. Lo scopo finale dell'attacco è trovare $x$, la chiave segreta.
		
		Per questo attacco, fissata una $x$, la vittima deve calcolare $y^{x} \ mod \ n$ per diversi valori di $y$ e l'attaccante deve conoscere $y$, $n$ e il tempo necessario al calcolo.
		Analizzando statisticamente queste misurazioni, si riesce a risalire all'intera chiave segreta.
		
		Le informazioni necessarie e le misurazioni temporali posso essere ottenute passivamente tramite qualche forma di intercettazione (ad esempio creando un \emph{man-in-the-middle}) sul protocollo di comunicazione fornito dalla vittima. L'attaccante a questo punto conosce il messaggio ricevuto dalla vittima e misura il tempo che essa impiega per rispondere con il risultato utilizzando i vari $y$.
		
		Questo attacco può essere adattato ad ogni implementazione di questa operazione all'unica condizione che non si tratti di una delle varianti che lavora in tempo costante.
		
		\subsection{Moltiplicazione di Montgomery e Teorema Cinese del Resto}
		In un'operazione di moltiplicazione modulo $n$, il passo di riduzione modulare è il principale responsabile delle variazioni nel tempo di esecuzione. La moltiplicazione di \emph{Montgomery}\cite{montgomery1985modular} elimina il passo di riduzione modulo $n$ riducendo il tempo totale dell'operazione e, di conseguenza, anche le variazioni associate.
		
		Per ottimizzare le operazioni che utilizzano la chiave privata di RSA viene utilizzato anche il \emph{teorema cinese del resto} (\ac{CRT}). Se il messaggio da cifrare è $y$, utilizzando il \ac{CRT} si calcolano inizialmente $(y \ mod \ p)$ e $(y \ mod \ q)$. Queste due operazioni iniziali sono la parte dell'algoritmo vulnerabile ai timing attacks. Il più semplice di questi attacchi sceglie un valore $y$ che si suppone vicino a $p$ o $q$. Successivamente utilizza i tempi di esecuzione per capire se $y$ sia più grande o più piccolo di $p$ (o di $q$). Se $y < p$, il calcolo di $y \ mod \ p$ non esegue alcuna operazione mentre, se $y \geq p$, sarà necessario sottrarre $p$ da $y$ almeno una volta aumentando il tempo di esecuzione.
		
		Le caratteristiche esatte dell'attacco dipendono dall'implementazione dell'algoritmo attaccato.
		
		\subsection{Digital Signature Algorithm}
		Il \ac{DSA} è uno standard \ac{FIPS} per la firma digitale proposto dal \ac{NIST} nell'agosto del 1991 per essere impiegato nel \ac{DSS}, adottato definitivamente nel 1993. Le sue specifiche sono contenute nel documento \ac{FIPS}-186\cite{kravitz1993digital}.
		
		Il \ac{DSS} calcola $s = (k^{-1}(H(m) + x \cdot r)) \ mod \ q$ dove $r$ e $q$ sono noti all'attaccante, $k^{-1}$ è precalcolato, $H(m)$ è l'hash del messaggio e $x$ è la chiave privata.
		
		Se l'operazione di riduzione modulo $q$ non è stata implementata per funzionare a tempo costante, il tempo totale di computazione è correlato col tempo necessario per calcolare $(x \cdot r \ mod \ q)$. L'attaccante può quindi calcolarlo in maniera similare alle precedenti e scoprire la chiave segreta $x$.
		
	\section{Generalizzazione}
	Abbiamo appena illustrato tre casi concreti di timing attacks contro specifici algoritmi crittografici. Partendo da queste basi, abbiamo cercato una generalizzazione applicabile alla maggior parte degli attacchi di questo tipo.
	
	Abbiamo notato che tutte le informazioni che vengono ricavate sono dovute al fatto che le variazioni del tempo di esecuzione dipendono, in qualche modo, dal segreto che l'attaccante vuole scoprire.
	
	Abbiamo supposto che l'attaccante prenda di mira una specifica istruzione \texttt{if} nel codice, come ad esempio \texttt{if p(h) then c} dove \texttt{p(.)} è un predicato con valore $0/1$ su \texttt{h}, in un contesto \texttt{B[.]}. In questo caso, l'intero programma sarebbe \texttt{B[if p(h) then c]}.
	
	Abbiamo assunto che il tempo di esecuzione dipenda da alcuni input forniti al programma che modificano l'esecuzione di \texttt{c}. Considerando i.i.d questi input e fissando il segreto \texttt{h}, abbiamo considerato il tempo di esecuzione dell'intero programma come una variabile aleatoria $\tcal$ che può essere divisa in $$\tcal = \talfa + \text{\texttt{p(h)}}\cdot \tbeta$$ dove $\talfa$ è il tempo di esecuzione dovuto a \texttt{B} e $\tbeta$ quello dovuto a \texttt{c} in una completa esecuzione di \texttt{B[c]}.
	
	Lo scopo dell'attaccante è quello di scoprire il valore di \texttt{p(h)} attraverso misurazioni del tempo di esecuzione dell'intero programma.
	
	A questo proposito, abbiamo dimostrato che $$var(\tcal) > var(\talfa) \Leftrightarrow \text{\texttt{p(h)} = 1}$$ 
	
	a condizione che 
	\begin{equation} \label{eq:1}
		var(\tbeta) > 2 \cdot |cov(\talfa,\tbeta)|.
	\end{equation}
		
	Questa formulazione però non basta all'attaccante perché, sebbene possa stimare facilmente $var(\tcal)$, non ha modo di stimare $var(\talfa)$ a meno che non sia in grado di eseguire \texttt{B} in isolamento (ipotesi troppo forte e poco realistica). Egli può però simulare \texttt{c}, calcolare $\tbeta$ e confrontare $var(\tcal - \tbeta)$ con $var(\tcal)$. A questo punto si ottiene che $$var(\tcal - \tbeta) < var(\tcal) \Leftrightarrow \text{\texttt{p(h)} = 1}.$$ Dimostrazione $\Leftarrow$:\\
	Se $\text{\texttt{p(h)}} = 1$, allora $$\tcal = \talfa + \tbeta \Rightarrow \tcal - \tbeta = \talfa$$
	da ciò si deduce che $$var(\tcal - \tbeta) = var(\talfa)$$ 
	e che $$var(\tcal) = var(\talfa) + var(\tbeta) + 2cov(\talfa,\tbeta)$$
	e quindi per la condizione \ref{eq:1} $$var(\tcal - \tbeta) < var(\tcal).$$Dimostrazione $\Rightarrow$:\\
	In questo caso dimostriamo la contronominale $$\text{\texttt{p(h)}} = 0 \Rightarrow var(\tcal - \tbeta) \geq var(\tcal).$$  
	Procediamo con la dimostrazione:
	$$\text{\texttt{p(h)}} = 0 \Rightarrow \tcal = \talfa + \text{\texttt{p(h)}}\cdot \tbeta = \talfa$$
	da cui si deduce che $$var(\tcal) = var(\talfa).$$
	Dal passo precedente 
	$$\tcal = \talfa \Rightarrow \tcal - \tbeta = \talfa - \tbeta$$
	e quindi
	$$var(\tcal - \tbeta) = var(\talfa) + var(\tbeta) - 2\cdot cov (\talfa,\tbeta)$$
	da cui per la condizione \ref{eq:1}
	$$var(\tcal - \tbeta) > var(\talfa) = var(\tcal).$$
	$\square$