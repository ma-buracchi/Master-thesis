\chapter{SPARK}
	In questo capitolo verrà analizzato \ac{SPARK}\index{SPARK}, il nostro attacco basato sul progetto SPECTRE capace di recuperare chiavi (o più in generale "segreti") evitando il controllo della password.
	
	\section{Scenario}
		Immaginiamo di partire dalla funzione attaccata da SPECTRE (\cref{list:vulnerabile}). Nello scenario più semplice si può pensare che \emph{array1} (da adesso sarà chiamato \emph{secret}) contenga delle chiavi predefinite assegnate ad ogni utente che vengono utilizzate come indici  per accedere ad \emph{array2} che contiene le informazioni riservate di tutti gli utenti. Dato che queste informazioni sono riservate, il tutto è protetto con una password. 
		
		L'utente \emph{x}, identificato tramite il proprio \emph{userID}, che vuole consultare i propri dati dovrà inserire ID e password (salvate nell'array delle password \emph{passwordDigest}). In caso di controllo positivo, si utilizzerà l'indice contenuto in \arr{secret}{userID} per andare a recuperare l'informazione che si riferisce ad \emph{x}. In caso di controllo negativo verrà ovviamente negato l'accesso ai dati.
		
		Tale funzione potrebbe essere implementata dal \cref{list:spark}:
		\codice{28}{32}{Funzione attaccata da SPARK}{list:spark}
		
		Supponiamo adesso che l'attaccante abbia accesso ad \emph{array2} (come supposto anche dall'attacco SPECTRE) ma che non abbia accesso a \emph{secret} ed ovviamente neanche all'array delle password. L'obiettivo del nostro attacco è quello di ricavare, per un utente casuale \emph{x}, il rispettivo \arr{secret}{x}, per poter successivamente avere accesso all'informazione riservata, il tutto senza conoscere la password.
		
		La precisione del risultato ottenuto dipende molto dal processore e dal tipo di dati utilizzato per rappresentare i vari valori. Nella nostra implementazione abbiamo utilizzato il tipo di dato \emph{int} grande trentadue bit; questo, in una cache con dimensione delle line pari a 512 bit (un valore considerato standard nei processori più moderni) non ci permette di recuperare esattamente \arr{secret}{x} (\cref{fig:lineSize}) ma di localizzarlo entro un certo intervallo \arr{secret}{x} $\pm \ \delta$ con, $$\delta = \frac{\text{dimensione di una line}}{\text{dimensione del tipo di dato}} = \frac{512}{32} = 16.$$
		
		\begin{figure}
			\begin{center}
				\includegraphics[width=.8\textwidth]{lineSize}
				\caption{Contenuto di una cache line nel nostro setup}
				\label{fig:lineSize}
			\end{center}
		\end{figure}
		
		\section{L'attacco}
			Prima di analizzare l'effettiva implementazione, vediamo l'idea generale dell'attacco che può essere suddiviso in quattro parti:
			
			\begin{enumerate}
				\item Il \ac{BP} viene addestrato richiamando la funzione vittima per tre volte con uno \emph{userID} e la relativa password corretta. Questo risultato è facilmente ottenibile dall'attaccante utilizzando i propri dati di accesso.
				\item Viene eseguito il \emph{flush} dalla cache di tutti i dati relativi ad \emph{array2} e \emph{passwordDigest}. Ricordiamo che l'istruzione \emph{clflush} non richiede alcun privilegio per essere eseguita.
				\item Viene richiamata la funzione vittima con lo \emph{userID} di cui vogliamo scoprire il segreto (chiamato \emph{userUnderAttack}) ed una password casuale.
				\item Si calcola il tempo necessario all'accesso di tutte le posizioni di \emph{array2}. Considerato che l'unico dato relativo ad \emph{array2} presente in cache in questo momento è \emph{y} = \arrdoppio{array2}{secret}{userUnderAttack} (per la chiamata precedente), solamente per questo otterremo un tempo basso mentre per tutti gli altri sarà alto perché dovranno essere recuperati dalla memoria principale.
			\end{enumerate}
		
			L'attacco funziona sfruttando l'esecuzione speculativa del processore sul controllo della password. Avendo eseguito il \emph{flush} di \emph{passwordDigest} al punto 2, \arr{passwordDigest}{userUnderAttack} non sarà presente in cache al momento del controllo al punto 3. Nell'attesa del suo recupero dalla memoria principale, il \ac{BP} eseguirà il ramo \emph{then} della computazione a causa dell'addestramento ottenuto al punto 1. Verrà richiesto dalla memoria \emph{y} che verrà caricato in cache. Quando sarà disponibile \arr{passwordDigest}{userUnderAttack}, il controllo fallirà e non verrà permesso l'accesso ai dati ma \emph{y} resterà in cache. A questo punto, accedendo a tutte le posizioni \arr{array2}{l} con \emph{l} $\in (0,\dots,\text{\emph{size(array2)}}-1)$ , l'unica che ci darà una risposta veloce sarà \emph{l} = \arr{secret}{userUnderAttack} e avremo così scoperto il valore segreto.
			
			\subsection{Implementazione}
				Passiamo adesso all'analisi dettagliata del nostro programma che implementa l'attacco.
				
				\subsubsection{Inizializzazione}
				\codspark{1}{22}{Inizializzazione}
				
				Nella primissima parte vengono semplicemente caricate le librerie necessarie alla compilazione, viene definito il numero di utenti (tremila), vengono creati i tre array principali \emph{secret},\emph{array2} e \emph{passwordDigest} e viene definita la funzione vittima, esattamente la stessa proposta nello scenario.
				
 				La libreria \emph{x86intrin} fornisce le istruzioni \emph{rdtscp} e \emph{\_\_mm\_clflush} necessarie al calcolo dei tempi di hit e al flush della cache. In particolare l'istruzione \emph{\_\_mm\_clflush} prende come argomento un indirizzo di memoria ed invalida, su tutti i livelli della cache, tutte le line che contengono quell'indirizzo.
				
				I tre array "utili" sono separati da altri array \emph{unused} per essere sicuri che vengano distanziati in memoria. Questo fa sì che non si sovrappongano all'interno di una stessa line.
				
				\subsubsection{Main - definizione parametri}
				\codspark{24}{52}{Main - definizione parametri}
				
				In questa parte vengono definiti i parametri che verranno utilizzati nel resto del programma:

					\emph{CACHELINE}: La dimensione in bit di una singola cache line. Come già detto, questa dimensione è ormai standardizzata a 512 bit su tutti i processori moderni.
					
					\emph{blocks}: La dimensione in bit di un singolo elemento dell'array. In questo caso 32 bit.
					
					\emph{delta}: Il numero di elementi dell'array che sono contenuti in una cache line.
					
					\emph{class}: Il numero di classi di risultati \emph{mod} $\delta$ ottenute.
					
					\emph{numberOfRuns}: Il numero di volte che viene eseguito l'attacco per ogni esperimento.
					
					\emph{numberOfTests}: Il numero di esperimenti che vengono eseguiti.
					
					\emph{cacheHitThreshold}: Il valore di soglia entro il quale si considera una cache hit. Sperimentalmente questo valore si aggira tra i 30 e i 40 cicli di clock.
					
					\emph{precisionLoss}: Con questo valore si regola la precisione che si vuole ottenere. Se lasciato a zero verrà restituito l'intervallo ($x-\delta, x+\delta$) che dovrebbe contenere il segreto. A volte però può succedere che venga fornito un intervallo che non contiene il segreto a causa di interferenze con altri processi che utilizzano il processore. Aumentando questo valore si aumenta l'intervallo proporzionalmente a $\delta$ perdendo un po' in precisione ma guadagnando in correttezza dell'intervallo.
					
					Questo e i tre precedenti sono i quattro parametri richiesti all'avvio del programma.
					
					\emph{results}: L'array nel quale verranno salvati i risultati.
					
					\emph{ok, error e no-hit}: Tre contatori utilizzati per sapere quante volte il programma trova il segreto, quante volte lo sbaglia e quante volte non rileva nessun cache hit.
					
					\emph{timeReg, time1 e time2}: Le tre variabili per calcolare i tempi di accesso alle posizioni di \emph{array2}.
			
				Dopo aver definito tutti i parametri si procede con l'inizializzazione del generatore \emph{srand} di numeri casuali.
				
				\subsubsection{Main - inizializzazione dell'esperimento}
				\codspark{54}{70}{Main - inizializzazione dell'esperimento}
				
				All'inizio di ogni test viene scelto casualmente lo \emph{userUnderAttack} e vengono inizializzati casualmente i tre array principali \emph{passwordDigest, array2} e \emph{secret}. Successivamente si sceglie una password sicuramente sbagliata ed infine si prepara l'array \emph{result} alla ricezione dei risultati settandolo a zero.
				
				\subsubsection{Main - l'attacco}
				\codspark{72}{99}{Main - l'attacco}
				
				Come descritto nello scenario, l'attacco si divide in quattro parti. Nella prima parte viene addestrato il \ac{BP} ad eseguire speculativamente il ramo then della funzione vittima richiamandola per tre volte con \emph{userID} e password corretta.
				
				Successivamente si esegue il flush dalla cache di tutte le posizioni degli array \emph{array2} e \emph{passwordDigest}.
				
				Prima di richiamare la funzione vittima abbiamo messo l'istruzione \emph{\_mm\_lfence}. Tale istruzione è una barriera sulla memoria che non permette l'esecuzione delle istruzioni successive prima che siano terminate tutte le scritture in memoria delle istruzioni precedenti. Questo evita ad esempio che l'istruzione a riga 90 venga eseguita prima del flush di \emph{array2} a causa di un riordinamento del codice. Se accadesse questo, il risultato del calcolo del tempo di accesso sarebbe ovviamente falsato.
				
				Terminato il flush della cache, viene richiamata la funzione vittima e vengono calcolati i tempi di accesso alle varie posizioni di \emph{array2}. Come si può notare, non si effettua l'accesso a tutte le posizioni di \emph{array2} ma si procede con un passo $\delta$ visto che comunque una qualunque delle $\delta$ posizioni all'interno della line restituirà una hit.
				
				Con un'altra \emph{\_mm\_lfence} ci assicuriamo che il tempo venga effettivamente salvato in \emph{time2} ed effettuiamo il controllo. Se il risultato del calcolo del tempo di accesso è minore della soglia che abbiamo impostato, aumentiamo di uno nell'array \emph{results} il valore  contenuto all'indice che stiamo analizzando.
				
				\subsubsection{Main - i risultati}
				\codspark{101}{138}{Main - i risultati}
				
				Nell'ultima parte del programma viene cercato l'indice \emph{index} con il valore più alto nell'array \emph{results} e viene calcolato il range nel quale si suppone stia il segreto limitato in basso da $0$ ed in alto da \emph{SIZE}. Tale range non è altro che: $$((index - 1 - precisionLoss) * \delta\ ,\ (index + 1 + precisionLoss) * \delta).$$ Il risultato così ottenuto viene infine comparato con \arr{secret}{userUnderAttack} e viene stabilito il risultato dell'attacco:
				
				\begin{itemize}
					\item \texttt{OK} - se il segreto ricade nel range calcolato.
					\item \texttt{ERROR} - se il segreto non ricade nel range calcolato.
					\item \texttt{NO-HIT} - se non si è rilevata alcuna hit.
				\end{itemize}