\chapter{SPARK}
	In questo capitolo verrà analizzato \ac{SPARK}\index{SPARK}, il nostro attacco basato sul progetto SPECTRE capace di recuperare chiavi (o più in generale "segreti") evitando il controllo della password.
	
	\section{Scenario}
		Immaginiamo di partire dalla funzione attaccata da SPECTRE (\cref{list:vulnerabile}). Nello scenario più semplice si può pensare che \emph{array1} (da adesso sarà chiamato \emph{secret}) contenga delle chiavi predefinite assegnate ad ogni utente che vengono utilizzate come indici  per accedere ad \emph{array2} che contiene le informazioni riservate di tutti gli utenti. Dato che queste informazioni sono riservate, il tutto è protetto con una password. 
		
		L'utente \emph{x}, identificato tramite il proprio \emph{userID}, che vuole consultare i propri dati dovrà inserire ID e password (salvate nell'array delle password \emph{passwordDigest}). In caso di controllo positivo, si utilizzerà l'indice contenuto in \arr{secret}{userID} per andare a recuperare l'informazione che si riferisce ad \emph{x}. In caso di controllo negativo verrà ovviamente negato l'accesso ai dati.
		
		Tale funzione potrebbe essere implementata dal \cref{list:spark}:
		\codice{28}{32}{Funzione attaccata da SPARK}{list:spark}
		
		Supponiamo adesso che l'attaccante abbia accesso ad \emph{array2} (come supposto anche dall'attacco SPECTRE) ma che non abbia accesso a \emph{secret} ed ovviamente neanche all'array delle password. L'obiettivo del nostro attacco è quello di ricavare, per un utente casuale \emph{x}, il rispettivo \arr{secret}{x}, per poter successivamente avere accesso all'informazione riservata, il tutto senza conoscere la password.
		
		La precisione del risultato ottenuto dipende molto dal processore e dal tipo di dati utilizzato per rappresentare i vari valori. Nella nostra implementazione abbiamo utilizzato il tipo di dato \emph{int} grande trentadue bit; questo, in una cache con dimensione delle line pari a 512 bit (un valore considerato standard nei processori più moderni) non ci permette di recuperare esattamente \arr{secret}{x} ma di localizzarlo entro un certo intervallo \arr{secret}{x} $\pm \ \delta$ con, $$\delta = \frac{\text{dimensione di una line}}{\text{dimensione del tipo di dato}} = \frac{512}{32} = 16.$$
		
		\section{L'attacco}
			Prima di analizzare l'effettiva implementazione, vediamo l'idea generale dell'attacco che può essere suddiviso in quattro parti:
			
			\begin{enumerate}
				\item Il \ac{BP} viene addestrato richiamando la funzione vittima per tre volte con uno \emph{userID} e la relativa password corretta. Questo risultato è facilmente ottenibile dall'attaccante utilizzando i propri dati di accesso.
				\item Viene eseguito il \emph{flush} dalla cache di tutti i dati relativi ad \emph{array2} e \emph{passwordDigest}. Ricordiamo che l'istruzione \emph{clflush} non richiede alcun privilegio per essere eseguita.
				\item Viene richiamata la funzione vittima con lo \emph{userID} di cui vogliamo scoprire il segreto (chiamato \emph{userUnderAttack}) ed una password casuale.
				\item Si calcola il tempo necessario all'accesso di tutte le posizioni di \emph{array2}. Considerato che l'unico dato relativo ad \emph{array2} presente in cache in questo momento è \emph{y} = \arrdoppio{array2}{secret}{userUnderAttack} (per la chiamata precedente), solamente per questo otterremo un tempo basso mentre per tutti gli altri sarà alto perché dovranno essere recuperati dalla memoria principale.
			\end{enumerate}
		
			L'attacco funziona sfruttando l'esecuzione speculativa del processore sul controllo della password. Avendo eseguito il \emph{flush} di \emph{passwordDigest} al punto 2, \arr{passwordDigest}{userUnderAttack} non sarà presente in cache al momento del controllo al punto 3. Nell'attesa del suo recupero dalla memoria principale, il \ac{BP} eseguirà il ramo \emph{then} della computazione a causa dell'addestramento ottenuto al punto 1. Verrà richiesto dalla memoria \emph{y} che verrà caricato in cache. Quando sarà disponibile \arr{passwordDigest}{userUnderAttack}, il controllo fallirà e non verrà permesso l'accesso ai dati ma \emph{y} resterà in cache. A questo punto, accedendo a tutte le posizioni \arr{array2}{l} con \emph{l} $\in (0,\dots,\text{\emph{size(array2)}}-1)$ , l'unica che ci darà una risposta veloce sarà \emph{l} = \arr{secret}{userUnderAttack} e avremo scoperto il valore segreto.
%		\begin{figure}
%			\begin{center}
%				\includegraphics[scale=.6]{lineSize}
%				\caption{Contenuto di una cache line nel nostro setup}
%				\label{fig:lineSize}
%			\end{center}
%		\end{figure}
		
	
		
		
%		Come si può vedere in \cref{fig:lineSize} ogni volta che viene richiesto il dato presente in una posizione di \emph{array2} (ad esempio \emph{array2}$[$\emph{i}$]$) e questo non si trova in cache, viene caricata un'intera line che può contenere sedici posizioni. Da quel momento, quando verrà richiesta una qualunque di quelle sedici, si otterrà una hit.
		 